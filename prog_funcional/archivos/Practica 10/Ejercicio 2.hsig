Ejercicio 2

data BExp = BCte Bool
            | Not BExp
            | And BExp BExp
            | Or BExp BExp
            | ROp RelOp NExp NExp

data RelOp = Eq | NEq -- Equal y NotEqual
            | Gt | GEq -- Greater y GreaterOrEqual
            | Lt | LEq -- Lower y LowerOrEqual


data NExp = Var Variable
            | NCte Int
            | NBOp NBinOp NExp NExp

data NBinOp = Add | Sub | Mul | Div | Mod | Pow


Implementar:

i)  ---- asumiendo que puedo usar los operadores que entienden los booleanos
evalBExp :: BExp -> Memoria -> Bool
evalBExp (BCte b) mem = b
evalBExp (Not be) mem = not (evalBExp be mem) 
evalBExp (And be1 be2) mem = (evalBExp be1 mem) && (evalBExp be2 mem)
evalBExp (Or be1 be2) mem = (evalBExp be1 mem) || (evalBExp be2 mem)
evalBExp (ROp rp ne1 ne2) mem = evalROp rp (evalNExp be1 mem) (evalNExp be2 mem) 

        evalROp :: RelOp -> Int -> Int -> Bool
        evalROp (Eq n1 n2) = n1 == n2
        evalROp (NEq n1 n2) = n1 /= n2
        evalROp (Gt n1 n2) = n1 > n2
        evalROp (GEq n1 n2) = n1 >= n2
        evalROp (Lt n1 n2) = n1 < n2
        evalROp (LEq n1 n2) = n1 =< n2


ii)
cfBExp :: BExp -> BExp
cfBExp (BCte b) = BCte b
cfBExp (Not be) = cfNot (cfBExp be)
cfBExp (And be1 be2) = cfAnd (cfBExp be1) (cfBExp be2)
cfBExp (Or be1 be2) = cfOr (cfBExp be1) (cfBExp be2)
cfBExp (ROp rp ne1 ne2) = cfROp rp (cfNExp ne1) (cfNExp ne2)
    
    cfNot :: BExp -> BExp
    cfNot (BCte b) = BCte (not b)
    cfNot be = Not be

    cfAnd :: BExp -> BExp -> BExp
    cfAnd (BCte b) be = if b then be else False
    cfAnd be1 be2 = And be1 be2

    cfOr :: BExp -> BExp -> BExp
    cfOr (BCte b) be = if b then b else be
    cfOr be1 be2 = Or be1 be2

    cfROp :: RelOp -> NExp -> NExp -> BExp
    cfROp (rop (Cte n) (Cte m)) = BCte (evalROp rop n m)
    cfROp rop ne1 ne2 = ROp rop ne1 ne2


Demostrar:

evalBExp . cfBExp = evalBExp
por ppio. de ext. para todo bexp.(evalBExp . cfBExp) bexp = evalBExp bexp
por def. de (.) evalBExp (cfBExp bexp) = evalBExp bexp
para toda memoria. evalBExp (cfBExp bexp) mem = evalBExp bexp mem

--demuestro por induccion estructural sobre bexp. Elijo bexp = bex

evalBExp (cfBExp bex) mem = evalBExp bex mem

Caso base 1. bex = BCte b                evalBExp (cfBExp (BCte b)) mem = evalBExp (BCte b) mem
--lado izq.
evalBExp (cfBExp (BCte b)) mem
= --def. de cfBExp
evalBExp (BCte b) mem --llego a lado derecho

--------------------------------------------


Caso base 2. bex = (ROp rp ne1 ne2)


evalBExp (cfBExp (ROp rp ne1 ne2)) mem = evalBExp (ROp rp ne1 ne2) mem

--lado izq.
evalBExp (cfBExp (ROp rp ne1 ne2)) mem
= --def. de crBExp
evalBExp (cfROp rp (cfNExp ne1) (cfNExp ne2)) mem
= -- LEMA 4
evalROp rp (evalNExp ne1 mem) (evalNExp ne2 mem) 


--lado der.
evalBExp (ROp rp ne1 ne2) mem
= --def. de evalBExp
evalROp rp (evalNExp ne1 mem) (evalNExp ne2 mem) 

        ------LEMA 4---------------
        evalBExp (cfROp rp ne1 ne2) mem = evalROp rp (evalNExp ne1 mem) (evalNExp ne2 mem) 

        --Demuestro por casos

        Caso ne1 = (Cte n), ne2 = (Cte m)

        evalBExp (cfROp rp (Cte n) (Cte m)) mem = evalROp rp (evalNExp (Cte n) mem) (evalNExp (Cte m) mem) 

        --lado izq.
        evalBExp (cfROp rp (Cte n) (Cte m)) mem 
        = --def. de cfROp
        evalBExp (BCte (evalROp rop n m)) mem
        = --def. de evalBExp
        evalROp rop n m


        --lado der. 
        evalROp rp (evalNExp (Cte n) mem) (evalNExp (Cte m) mem)
        = --def. de evalNExp
        evalROp rp n m

        Caso ne1 /= (Cte n), ne2 /= (Cte m)

        evalBExp (cfROp rp ne1 ne2) mem = evalROp rp (evalNExp ne1 mem) (evalNExp ne2 mem)

        --lado izq.
        evalBExp (cfROp rp ne1 ne2) mem
        = --def. cfROp
        evalBExp (ROp rop ne1 ne2) mem
        = --def. de evalBExp
         evalROp rop (evalNExp ne1 mem) (evalNExp ne2 mem) 
        --llego a lado derecho
        ----------------------------------------------LEMA 4 demostrado-----------------

---------------------------------------------------------------------------------------------

Caso inductivo 1. bex = (Not be)
HI) evalBExp (cfBExp be) mem = evalBExp be mem
TI) ¿evalBExp (cfBExp (Not be)) mem = evalBExp (Not be) mem?

--lado izq.
evalBExp (cfBExp (Not be)) mem
= --def. de cfBExp
evalBExp (cfNot (cfBExp be)) mem
= -- LEMA 1
not (evalBExp (cfBExp be) mem)

--lado der.
evalBExp (Not be) mem
= --def. de evalBExp
not (evalBExp be mem) 
= --por HI
not (evalBExp (cfBExp be) mem)

    ---------------LEMA 1-------------
    evalBExp (cfNot be) mem = not (evalBExp be mem)

    --Demuestro por casos

    Caso be = (BCte b)
    --lado izq.
    evalBExp (cfNot (BCte b)) mem
    = --def. de cfNot
    evalBExp (BCte (not b)) mem
    = --def. de evalBExp
    not b mem

    --lado der.
    not (evalBExp (BCte b) mem)
    = --def. de evalBExp
    not b mem

    -------

    Caso be /= (BCte b)

    --lado izq.
    evalBExp (cfNot be) mem
    = --def. de cfNot
    evalBExp (Not be) mem
    = -- def. de evalBExp
    not (evalBExp be mem) --llegue a lado derecho

    -----------------LEMA 1 demostrado-------------------------

---------------------------------------------
Caso inductivo 2. bex = (And be1 be2)
HI1) evalBExp (cfBExp be1) mem = evalBExp be1 mem
HI2) evalBExp (cfBExp be2) mem = evalBExp be2 mem
TI) ¿evalBExp (cfBExp (And be1 be2)) mem = evalBExp (And be1 be2) mem?

--lado izq.
evalBExp (cfBExp (And be1 be2)) mem
= --def. cfBExp
evalBExp (cfAnd (cfBExp be1) (cfBExp be2)) mem
= --LEMA 2
(evalBExp (cfBExp be1) mem) && (evalBExp (cfBExp be2) mem)
= --por HI 1 y 2
(evalBExp be1 mem) && (evalBExp be2 mem)


--lado der.
evalBExp (And be1 be2) mem
= --def. de evalBExp
(evalBExp be1 mem) && (evalBExp be2 mem)

    --------------LEMA 2-------------------
    evalBExp (cfAnd be1 be2) mem = (evalBExp be1 mem) && (evalBExp be2 mem)

    ---Demuestro por casos
    Caso be1 = (BCte b), be2 /= (BCte b)

    --lado izq.
    evalBExp (cfAnd (BCte b) be2)) mem
    = --LEMA 2.1
    evalBExp (Bcte b) mem && evalBExp be2 mem
    = --def. de evalBExp
    b && (evalBExp be2 mem)

    --lado der.
    (evalBExp (BCte b) mem) && (evalBExp be2 mem)
    = --def. de evalBExp
    b && (evalBExp be2 mem) 

    -------LEMA 2 demostrado-------------------------

                ------------LEMA 2.1-----------

                evalBExp (cfAnd (BCte b) be2)) mem = evalBExp (Bcte b) mem && evalBExp be2 mem
                --Demuestro por casos

                Caso b = False
                --lado izq.
                evalBExp (cfAnd (BCte False) be2)) mem
                = --def. de cfAnd
                evalBExp (BCte False) mem
                = --def. de evalBExp
                False

                --lado der.
                evalBExp (Bcte False) mem && evalBExp be2 mem
                = --def. de evalBExp
                False && evalBExp be2 mem
                = --def. de &&
                False

                Caso b = True
                --lado izq.
                evalBExp (cfAnd (BCte True) be2)) mem
                = --def. de cfAnd
                evalBExp be2 mem

                --lado der.
                evalBExp (Bcte True) mem && evalBExp be2 mem
                = --def. de evalBExp
                True && evalBExp be2 mem
                = --def. de &&
                evalBExp be2 mem
                -----------------------------LEMA 2.1 demostrado----------------------

    Caso be1 /= (BCte b), be2 /= (BCte b)
    evalBExp (cfAnd be1 be2) mem = (evalBExp be1 mem) && (evalBExp be2 mem)

    --lado izq.
    evalBExp (cfAnd be1 be2) mem
    = --def. cfAnd
    evalBExp (And be1 be2) mem
    = --def. evalBExp
    (evalBExp be1 mem) && (evalBExp be2 mem) --llego 
----------------------------------LEMA 2 demostrado-------------------------------------
--------------------------------------------------------------------

Caso inductivo 3. bex = (Or be1 be2)
HI1) evalBExp (cfBExp be1) mem = evalBExp be1 mem
HI2) evalBExp (cfBExp be2) mem = evalBExp be2 mem
TI) ¿evalBExp (cfBExp (Or be1 be2)) mem = evalBExp (Or be1 be2) mem?

--lado izq.
evalBExp (cfBExp (Or be1 be2)) mem
= -- def. cfBExp
evalBExp (cfOr (cfBExp be1) (cfBExp be2)) mem
= --LEMA 3
(evalBExp (cfBExp be1) mem) || (evalBExp (cfBExp be2) mem)
= --por HI 1 y 2
(evalBExp be1 mem) || (evalBExp be2 mem)

--lado der.
evalBExp (Or be1 be2) mem
= --def. de evalBExp
(evalBExp be1 mem) || (evalBExp be2 mem)

    -------------------LEMA 3-------------------------
    evalBExp (cfOr be1 be2) mem = (evalBExp be1 mem) || (evalBExp be2 mem)

    --Demuestro por casos

    Caso be1 /= (BCte b), be2 /= (BCte b)
    --lado izq.
    evalBExp (cfOr be1 be2) mem
    = --def. de cfOr
    evalBExp (Or be1 be2) mem
    = --def. de evalBExp
    (evalBExp be1 mem) || (evalBExp be2 mem) -- llego a lado derecho



    Caso be1 = (BCte b), be2 /= (BCte b)
    --lado izq.
    evalBExp (cfOr (BCte b) be2) mem
    = --LEMA 3.1
    (evalBExp be1 mem) || (evalBExp be2 mem)

            ---------LEMA 3.1-----------

            evalBExp (cfOr (BCte b) be2)) mem = evalBExp (Bcte b) mem || evalBExp be2 mem
                --Demuestro por casos

                Caso b = False
                --lado izq.
                evalBExp (cfOr (BCte False) be2)) mem
                = --def. de cfOr
                evalBExp be2 mem

                --lado der.
                evalBExp (Bcte False) mem || evalBExp be2 mem
                = --def. de evalBExp
                False || evalBExp be2 mem
                = --def. de ||
                evalBExp be2 mem

                Caso b = True
                --lado izq.
                evalBExp (cfOr (BCte True) be2)) mem
                = --def. de cfOr
                evalBExp (BCte True) mem
                = --def. de evalBExp
                True

                --lado der.
                evalBExp (Bcte True) mem || evalBExp be2 mem
                = --def. de evalBExp
                True || evalBExp be2 mem
                = --def. de ||
                True

                ----------LEMA 3.1 demostrado
    -------------------------------------LEMA 3 demostrado--------------------------

